(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.compareVersion = factory());
})(this, (function () { 'use strict';

  //检查版本号是否合法
  function checkVersion(version) {
    if (!this.version) return false;
    //格式如 0.0.1；
    const isPass = /^[0-9]{1,}((\.[0-9]+)+)?$/.test(version);
    if (!isPass) {
      console.error(`版本号[${version}]输入有误 期望格式 → [number1.number2.number3]`);
    }
    return isPass;
  }

  //找最大数字
  function getMaxNum(list) {
    list = list.map((num) => num);
    list.sort((a, b) => a - b);
    return list[list.length - 1];
  }

  //找最大长度的项
  function getNumMaxLength(list = []) {
    list = list.map((num) => String(num));
    let maxLen = list[0].length;
    list.forEach((num) => {
      if (maxLen < num.length) maxLen = num.length;
    });
    return maxLen;
  }

  /*
  * 对齐版本号长度
  * */
  function alignVersionLength(versionList) {
    const versionLengthList = versionList.map((el) => el.length);
    const maxLen = getMaxNum(versionLengthList);

    /*
    * 所有项总长度对齐
    * 输入 [1,20,3], [2,3,4,5]
    * 输出 [1,20,3,0], [2,3,4,5]
    * */
    const newVersionList = versionList.map((list) => {
      let fillList = [];//需要填充的元素
      if (maxLen > list.length) {
        fillList = (new Array(maxLen - list.length)).fill('0').map((el) => el);
      }
      return [...list, ...fillList];
    });
    // console.log('newVersionList', newVersionList)

    /*
    * 把输入的数组各项组成一个二维数组，并在每个子数组中算出最长项的长度
    * 输入 [1, 20, 3, 0], [2, 3, 4, 5]
    * 组合 [ [1, 2], [20, 3], [3, 4], [0, 5] ]
    * 输出 [1, 2, 1, 1]
    * */
    const listBlockLen = new Array(maxLen).fill('').map((el, i) => {
      let item = [];
      newVersionList.forEach((list) => item.push(list[i]));
      return item;
    });
    const versionItemLengthList = listBlockLen.map((el) => getNumMaxLength(el));
    // console.log('versionItemLengthList', versionItemLengthList);
    const result = newVersionList.map((list, listIndex) => {
      const item = list.map((el, i) => {
        let fillList = [];
        if (el.length < versionItemLengthList[i]) {
          fillList = new Array(versionItemLengthList[i] - el.length).fill('0').map((empty) => empty);
        }
        fillList = fillList.join('');
        return fillList + el;
      });
      // console.log(`item-${listIndex}`, item)
      return item.join('');
    });
    // console.log('result', result)

    return result;
  }

  function CompareVersion(version) {
    this.version = [];
    this.firstVersion = version;
    if (this.checkVersion(version)) {
      this.version = version.split('.');
    } else {
      this.version = null;
    }
  }

  CompareVersion.prototype.checkVersion = checkVersion;
  //等于
  CompareVersion.prototype.isSame = function (version, showLog = true) {
    if (!this.checkVersion(version)) return null;
    const versionStr = version;
    version = version.split('.');
    const [version1, version2] = alignVersionLength([this.version, version]);
    const result = version1 === version2;

    showLog && console.info(`${this.firstVersion}等于${versionStr}`, result);
    return result
  };
  //小于
  CompareVersion.prototype.isBefore = function (version, showLog = true) {
    if (!this.checkVersion(version)) return null;
    const versionStr = version;
    version = version.split('.');
    const [version1, version2] = alignVersionLength([this.version, version]);
    const result = version1 < version2;

    showLog && console.info(`${this.firstVersion}小于${versionStr}`, result);
    return result;
  };
  //大于
  CompareVersion.prototype.isAfter = function (version, showLog = true) {
    if (!this.checkVersion(version)) return null;
    const versionStr = version;
    version = version.split('.');
    const [version1, version2] = alignVersionLength([this.version, version]);
    const result = version1 > version2;

    showLog && console.info(`${this.firstVersion}大于${versionStr}`, result);
    return result;
  };
  //小于等于
  CompareVersion.prototype.isSameOrBefore = function (version, showLog = true) {
    const result = this.isSame(version, false) || this.isBefore(version, false);

    showLog && console.info(`${this.firstVersion}小于等于${version}`, result);
    return result;
  };
  //大于等于
  CompareVersion.prototype.isSameOrAfter = function (version, showLog = true) {
    const result = this.isSame(version, false) || this.isAfter(version, false);

    showLog && console.info(`${this.firstVersion}大于等于${version}`, result);
    return result;
  };
  //虚心区间内
  CompareVersion.prototype.isBetween = function (versionStart, versionEnd) {
    if (!versionEnd) versionEnd = versionStart;
    const result = this.isAfter(versionStart, false) && this.isBefore(versionEnd, false);
    const versionStartStr = versionStart;
    const versionEndStr = versionEnd;

    console.info(`${this.firstVersion}在(${versionStartStr}, ${versionEndStr})之间`, result);
    return result;
  };
  //实心区间内
  CompareVersion.prototype.isSameOrBetween = function (versionStart, versionEnd) {
    if (!versionEnd) versionEnd = versionStart;
    const result = this.isSameOrAfter(versionStart, false) && this.isSameOrBefore(versionEnd, false);
    const versionStartStr = versionStart;
    const versionEndStr = versionEnd;

    console.info(`${this.firstVersion}在[${versionStartStr}, ${versionEndStr}]之间`, result);
    return result;
  };

  function main (version) {
    return new CompareVersion(version);
  }

  return main;

}));
